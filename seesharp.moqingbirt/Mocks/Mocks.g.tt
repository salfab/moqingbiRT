<#
/*
Copyright (c) Pawel Kadluczka. All rights reserved.

AS IS, NO WARRANTY, USE ON YOUR OWN RISK

T4 template for creating pre-generated views for Entity Framework Code First application

Usage: 
1. Add this template to your project
2. Rename this template so that its name contains the name of your DbContext derived class (e.g. MyContext.Views.tt)
3. Right-click the template file in the Solution Explorer and select "Run Custom Tool"
4. If you have more than one DbContext derived class in your project you need to add a separate template for each
DbContext derived class you want to create pre-generated views for. 
*/
#>
/*
* Copyright (c) seesharp.ch. All rights reserved.
* Please, reference the main page of the product when using it. https://github.com/salfab/moqingbirt
* more formal license will come as the MoqingbiRT framework gets more features.
* Do *not* edit or commit this file to your VCS : it will be autogenerated and overwritten.
* This file contains all the underlying implementations for the types which need to be mocked. (i.e. all the interfaces found in your projects)
*/
<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="$(SolutionDir)seesharp.moqingbirt.TestBench\bin\Debug\seesharp.moqingbirt.TestBench.dll"#>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ assembly name="System.Collections" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data.Entity" #>
<#@ assembly name="System.Data.Entity.Design" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="EnvDTE" #>
<#@ import namespace="EnvDTE" #>		
<#	 
		var absoluteDllPaths = new List<string>();
		var serviceProvider = Host as IServiceProvider;
		var dte = serviceProvider.GetService(typeof(DTE)) as DTE;
		var projects = dte.Solution.Projects;//this.Host.ResolveParameterValue("-", "-", "projects").Split('|');
		WriteLine("// Mocks generated for :");			

		foreach(var project in projects)
		{
			WriteLine(string.Empty);
			string projectFullPath = string.Empty;
			string outputFileName = string.Empty;
			string outputPath = string.Empty;
			var configManager = ((EnvDTE.Project)project)					
					.ConfigurationManager;
			if(configManager != null)
			{
				var activeConfig = configManager.ActiveConfiguration;
					 var msg = string.Empty;					 
					 
					 foreach (Property prop in ((EnvDTE.Project)project).Properties)
					 {			
						if(prop.Name == "FullPath")
						{
							projectFullPath= prop.Value.ToString();
					 		WriteLine("// " + prop.Name + " = " + prop.Value);				
						}
						if(prop.Name == "OutputFileName")
						{
							outputFileName = prop.Value.ToString();
					 		WriteLine("// " + prop.Name + " = " + prop.Value);				
						}
						var val = "null";
						try
						{
						if(prop.Value != null) 
							val = prop.Value.ToString();
						}
						catch
						{
						}			
					 }
					 					 
					 foreach (Property prop in activeConfig.Properties)
					 {		
						if(prop.Name == "OutputPath")							   
						{
							outputPath = prop.Value.ToString();
							WriteLine("// " + prop.Name + " = " + prop.Value);	
						}
					 	//msg += " \r\n//   " + prop.Name + " = " + prop.Value;				
					 }
					 //WriteLine(msg);
					 var absoluteDllPath = Path.Combine(Path.Combine(projectFullPath, outputPath), outputFileName);
					 absoluteDllPaths.Add(absoluteDllPath);
					 WriteLine("// --> " + absoluteDllPath);
			}
		}
		// var resolvedprojects = this.Host.ResolveParameterValue("-", "-", "projects").Split('|');
		// foreach(var project in resolvedprojects)
		// {
		// 	var yay = dte.Solution.FullName  ;
		// 
		// 	WriteLine("//" + yay.ToString());
		// 	WriteLine("//" + this.Host.ResolvePath("..\\" +  project  )  );
		// }

		var v = System.Reflection.Assembly.LoadFile(absoluteDllPaths.ElementAt(2));
		foreach(var dllPath in absoluteDllPaths.Where(p => p.EndsWith("Mocks.dll")))
		{
			foreach(var type in v.ExportedTypes.Where(o => o.GetTypeInfo().IsInterface))
			{
				WriteLine("namespace " + type.Namespace +".Mocks\r\n{");	
				WriteLine("    using System;");	
				WriteLine("    using System.Linq;");	
				WriteLine(string.Empty);			
				WriteLine(string.Format("    public class {0}Mock : MockBase, {1}", type.Name.TrimStart('I'), type.Name));
				WriteLine("    {");	
				foreach(var method in type.GetRuntimeMethods().Where(o=>!o.IsSpecialName))
				{
					string typeName;
					if(method.ReturnType == typeof(void))
					{
						typeName = "void";
					}
					else
					{
						typeName = method.ReturnType.FullName;					
					}
					Write(string.Format("        public {0} {1}(",  typeName , method.Name));	
					var parameters = method.GetParameters();
					foreach(var param in parameters)
					{
						Write(string.Format("{0} {1}", param.ParameterType.FullName, param.Name));	
					
					}
					WriteLine(")");
					 
					WriteLine("        {");	
					Write("            var callRecord = new Tuple<string, object[]>( \"" + method.Name + "\", new object[] { ");
					if(parameters.Count() == 0)
					{
						Write("null");	
					}
					else
					{
						Write(parameters[0].Name);	
						foreach(var param in parameters.Skip(1))
						{					
							Write(string.Format(", {0}", param.Name));	
					
						}
					}
					WriteLine(" });");	
					WriteLine("            this.Calls.Add(callRecord);");	
					// within the body of the class.



					// return value of the method 
					if (method.ReturnType != typeof(void))
					{
						WriteLine("            return default("+ method.ReturnType.FullName +");");	
					}
					WriteLine("        }");					
					WriteLine(string.Empty);					


				}
						
				foreach(var property in type.GetRuntimeProperties())
				{
					WriteLine("        public " + property.PropertyType.FullName+ " " + property.Name);	
					WriteLine("        { ");
				
					// TODO : Record the calls
					WriteLine("            get");					
					WriteLine("            {");					
					WriteLine("                this.PropertyGetCalls.Add(\""+ property.Name +"\");");				
					WriteLine("                return ("+property.PropertyType.FullName+")this.Setups.Single(o => o.Item1 == \"" + property.Name + "\").Item3;");					
					WriteLine("            }");					
								
				
					// TODO : Record the calls
					WriteLine("            set");					
					WriteLine("            {");										
					WriteLine("                if (!this.IsVerifySetInProgess)");				
					WriteLine("                {");				
					WriteLine("                    this.PropertySetCalls.Add(new Tuple<string, object>(\""+ property.Name +"\", value));");				
					WriteLine("                }");				
					WriteLine("                else");				
					WriteLine("                {");				
					WriteLine("                    // todo : make a single object containing the count AND the name of the method last verified.");				
					WriteLine("                    this.LastVerifySetMatchesCount = this.PropertySetCalls.Count(o => o.Item1 == \"" + property.Name + "\" && MatchIt<"+property.PropertyType.FullName+">.LastMatch != null ? MatchIt<"+property.PropertyType.FullName+">.LastMatch(value) : ("+property.PropertyType.FullName+")o.Item2 ==  value);");				
					WriteLine("                    this.LastVerifySetPropertyName = \"" + property.Name + "\";");		
					WriteLine("                    MatchIt<"+ property.PropertyType.FullName +">.LastMatch = null;");				
					WriteLine("                }");				
					WriteLine("            }");				
				
					WriteLine("        }");	

				}

				WriteLine("    }");	
				WriteLine("}");	
				WriteLine(string.Empty);

			}		
		}
#>
