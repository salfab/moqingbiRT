<#
/*
Copyright (c) Pawel Kadluczka. All rights reserved.

AS IS, NO WARRANTY, USE ON YOUR OWN RISK

T4 template for creating pre-generated views for Entity Framework Code First application

Usage: 
1. Add this template to your project
2. Rename this template so that its name contains the name of your DbContext derived class (e.g. MyContext.Views.tt)
3. Right-click the template file in the Solution Explorer and select "Run Custom Tool"
4. If you have more than one DbContext derived class in your project you need to add a separate template for each
DbContext derived class you want to create pre-generated views for. 
*/
#>
/*
* Copyright (c) seesharp.ch. All rights reserved.
* Please, reference the main page of the product when using it. https://github.com/salfab/moqingbirt
* more formal license will come as the MoqingbiRT framework gets more features.
* Do *not* edit or commit this file to your VCS : it will be autogenerated and overwritten.
* This file contains all the underlying implementations for the types which need to be mocked. (i.e. all the interfaces found in your projects)
*
* Usage : Most likely, the project containing this file will not compile, because it is missing some references. 
*         Please, add all the references needed (i.e. all the assemblies in which there are interfaces to be mocked) and the project will compile.
*         Note : this is a one-time operation only. Once added, the references do not need to be re-added until a new project is added to the solution.
*/
<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ assembly name="System.Collections" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data.Entity" #>
<#@ assembly name="System.Data.Entity.Design" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ import namespace="EnvDTE" #>		
<#@ import namespace="EnvDTE80" #>	
<#	 
		var absoluteDllPaths = new List<string>();
		var serviceProvider = Host as IServiceProvider;
		var dte = serviceProvider.GetService(typeof(DTE)) as DTE;
		var projects = dte.Solution.Projects;//this.Host.ResolveParameterValue("-", "-", "projects").Split('|');
		WriteLine("// Please, make sure the current project references the following assemblies as project references :");	

		foreach(var project in projects)
		{
			string projectFullPath = string.Empty;
			string outputFileName = string.Empty;
			string outputPath = string.Empty;
			var configManager = ((EnvDTE.Project)project)					
					.ConfigurationManager;			
			if(configManager != null)
			{
				var activeConfig = configManager.ActiveConfiguration;
					 var msg = string.Empty;					 
					 
					 foreach (Property prop in ((EnvDTE.Project)project).Properties)
					 {			
						 if(prop.Name == "FullPath")
						 {
						 	projectFullPath= prop.Value.ToString();
					 	 	//WriteLine("// " + prop.Name + " = " + prop.Value);				
						 }
						if(prop.Name == "OutputFileName")
						{
							outputFileName = prop.Value.ToString();
					 		//WriteLine("// " + prop.Name + " = " + prop.Value);				
						}
						var val = "null";
						try
						{
						if(prop.Value != null) 
							val = prop.Value.ToString();
						}
						catch
						{
						}			
					 }
					 					 
					 foreach (Property prop in activeConfig.Properties)
					 {		
						if(prop.Name == "OutputPath")							   
						{
							outputPath = prop.Value.ToString();
							//WriteLine("// " + prop.Name + " = " + prop.Value);	
						}
					 	//msg += " \r\n//   " + prop.Name + " = " + prop.Value;				
					 }
					 //WriteLine(msg);
					 var absoluteDllPath = Path.Combine(Path.Combine(projectFullPath, outputPath), outputFileName);
					 absoluteDllPaths.Add(absoluteDllPath);
					 // WriteLine("// " + absoluteDllPath);

					 // Improve : instead of comparing with a hardcoded string, compare it with the current project.
					 if (outputFileName != "Mocks.dll")
					 {
						WriteLine("// " + outputFileName);
					 }
			}
		}
		WriteLine("\r\n// Items contained within this solution :");			

		foreach(var project in projects)
		{
			WriteLine(string.Empty);
			string projectFullPath = string.Empty;
			string outputFileName = string.Empty;
			string outputPath = string.Empty;
			var configManager = ((EnvDTE.Project)project)					
					.ConfigurationManager;
			HandleProjectItems(((EnvDTE.Project)project).ProjectItems);
			/*
			if(configManager != null)
			{
				var activeConfig = configManager.ActiveConfiguration;
					 var msg = string.Empty;					 
					 
					 foreach (Property prop in ((EnvDTE.Project)project).Properties)
					 {			
						if(prop.Name == "FullPath")
						{
							projectFullPath= prop.Value.ToString();
					 		WriteLine("// " + prop.Name + " = " + prop.Value);				
						}
						if(prop.Name == "OutputFileName")
						{
							outputFileName = prop.Value.ToString();
					 		WriteLine("// " + prop.Name + " = " + prop.Value);				
						}
						var val = "null";
						try
						{
						if(prop.Value != null) 
							val = prop.Value.ToString();
						}
						catch
						{
						}			
					 }
					 					 
					 foreach (Property prop in activeConfig.Properties)
					 {		
						if(prop.Name == "OutputPath")							   
						{
							outputPath = prop.Value.ToString();
							WriteLine("// " + prop.Name + " = " + prop.Value);	
						}
					 	//msg += " \r\n//   " + prop.Name + " = " + prop.Value;				
					 }
					 //WriteLine(msg);
					 var absoluteDllPath = Path.Combine(Path.Combine(projectFullPath, outputPath), outputFileName);
					 absoluteDllPaths.Add(absoluteDllPath);
					 WriteLine("// --> " + absoluteDllPath);
			}*/
		}
		// var resolvedprojects = this.Host.ResolveParameterValue("-", "-", "projects").Split('|');
		// foreach(var project in resolvedprojects)
		// {
		// 	var yay = dte.Solution.FullName  ;
		// 
		// 	WriteLine("//" + yay.ToString());
		// 	WriteLine("//" + this.Host.ResolvePath("..\\" +  project  )  );
		// }
		/*
		var v = System.Reflection.Assembly.LoadFile(absoluteDllPaths.ElementAt(2));
		foreach(var dllPath in absoluteDllPaths.Where(p => p.EndsWith("Mocks.dll")))
		{
			foreach(var type in v.ExportedTypes.Where(o => o.GetTypeInfo().IsInterface))
			{
				WriteLine("namespace " + type.Namespace +".Mocks\r\n{");	
				WriteLine("    using System;");	
				WriteLine("    using System.Linq;");	
				WriteLine(string.Empty);			
				WriteLine(string.Format("    public class {0}Mock : MockBase, {1}", type.Name.TrimStart('I'), type.Name));
				WriteLine("    {");	
				foreach(var method in type.GetRuntimeMethods().Where(o=>!o.IsSpecialName))
				{
					string typeName;
					if(method.ReturnType == typeof(void))
					{
						typeName = "void";
					}
					else
					{
						typeName = method.ReturnType.FullName;					
					}
					Write(string.Format("        public {0} {1}(",  typeName , method.Name));	
					var parameters = method.GetParameters();
					foreach(var param in parameters)
					{
						Write(string.Format("{0} {1}", param.ParameterType.FullName, param.Name));	
					
					}
					WriteLine(")");
					 
					WriteLine("        {");	
					Write("            var callRecord = new Tuple<string, object[]>( \"" + method.Name + "\", new object[] { ");
					if(parameters.Count() == 0)
					{
						Write("null");	
					}
					else
					{
						Write(parameters[0].Name);	
						foreach(var param in parameters.Skip(1))
						{					
							Write(string.Format(", {0}", param.Name));	
					
						}
					}
					WriteLine(" });");	
					WriteLine("            this.Calls.Add(callRecord);");	
					// within the body of the class.



					// return value of the method 
					if (method.ReturnType != typeof(void))
					{
						WriteLine("            return default("+ method.ReturnType.FullName +");");	
					}
					WriteLine("        }");					
					WriteLine(string.Empty);					


				}
						
				foreach(var property in type.GetRuntimeProperties())
				{
					WriteLine("        public " + property.PropertyType.FullName+ " " + property.Name);	
					WriteLine("        { ");
				
					// TODO : Record the calls
					WriteLine("            get");					
					WriteLine("            {");					
					WriteLine("                this.PropertyGetCalls.Add(\""+ property.Name +"\");");				
					WriteLine("                return ("+property.PropertyType.FullName+")this.Setups.Single(o => o.Item1 == \"" + property.Name + "\").Item3;");					
					WriteLine("            }");					
								
				
					// TODO : Record the calls
					WriteLine("            set");					
					WriteLine("            {");											
					WriteLine("                if (!this.IsVerifySetInProgess && !this.IsSetterArgumentEvaluationInProgess)");				
					WriteLine("                {");				
					WriteLine("                    this.PropertySetCalls.Add(new Tuple<string, object>(\""+ property.Name +"\", value));");				
					WriteLine("                }");				
					WriteLine("                else");				
					WriteLine("                {");				
					WriteLine("                    // todo : make a single object containing the count AND the name of the method last verified.");				
					WriteLine("                    this.LastVerifySetMatchesCount = this.PropertySetCalls.Count(o => o.Item1 == \"" + property.Name + "\" && MatchIt<"+property.PropertyType.FullName+">.LastMatch != null ? MatchIt<"+property.PropertyType.FullName+">.LastMatch(value) : ("+property.PropertyType.FullName+")o.Item2 ==  value);");				
					WriteLine("                    this.LastVerifySetPropertyName = \"" + property.Name + "\";");		
					WriteLine("                    MatchIt<"+ property.PropertyType.FullName +">.LastMatch = null;");				
					WriteLine("                }");	 
					WriteLine(string.Empty);				
					WriteLine("                // Maybe using an enum and a switch case instead of multiple if is better.");				
					WriteLine("                if (this.IsSetterArgumentEvaluationInProgess)");				
					WriteLine("                {");				
					WriteLine("                    this.PropertySetCalls.Add(new Tuple<string, object>(\""+ property.Name +"\", value));");				
					WriteLine("                }");				
					WriteLine("            }");				
				
					WriteLine("        }");	

				}

				WriteLine("    }");	
				WriteLine("}");	
				WriteLine(string.Empty);

			}		
		}*/
#>
<#+
    private void HandleProjectItems(ProjectItems projectItems)
    {
        foreach(ProjectItem pi in projectItems)
			{
				// Pay attention to the interface ISpecifiedServiceInOtherNamespace : it is in a sub-namespace : do we resolve it ?
				WriteLine("// project item name : " + pi.Name);
				if(pi.ProjectItems != null)
				{
					// WriteLine("// project item's Project Items : " + pi.ProjectItems);
					HandleProjectItems(pi.ProjectItems);
				}
				if (pi.FileCodeModel != null)
				{
					foreach(CodeElement item in pi.FileCodeModel.CodeElements)
					{
						if(item.Kind.ToString() == "vsCMElementNamespace" && ((CodeNamespace)item).Name != "seesharp.moqingbirt")
						{
							foreach(CodeElement ce in ((CodeNamespace)item).Members)
							{
								var ce2 = ce as CodeInterface;
								if(ce2 != null)
								{
									WriteLine("//     Interface name : " + ce2.Name);
									WriteLine("namespace " + ((CodeNamespace)item).Name +".Mocks\r\n{");	
									WriteLine("    using System;");	
									WriteLine("    using System.Linq;");	
									WriteLine("    using seesharp.moqingbirt;");	
									WriteLine("    using "+((CodeNamespace)item).Name +";");	
									WriteLine(string.Empty);			
									WriteLine(string.Format("    internal class {0}Mock : MockBase, {1}", ce2.Name.Substring(1), ce2.Name));
									WriteLine("    {");	
									// implement members of ce2
									GenerateInterfaceMembers(ce2);
									WriteLine("    }");	
									WriteLine("}");	
									WriteLine(string.Empty);
								}
								// var ce3 = ce as CodeClass;
								// if(ce3 != null)
								// {
								// 	WriteLine("// member Class : " + ce3.Name);							
								// }
								// else
								// {
								// 	WriteLine("// member Class : " + ce.Kind);
								// }
							}
						}
						// WriteLine("// NameSpace : " + ((CodeNamespace)item).Name);

					}
				}
			}
    }
#>
<#+
	private void GenerateInterfaceMembers(CodeInterface ce2)
	{
		foreach(CodeElement interfaceMember in ce2.Members)
		{
			// WriteLine("//         member of interface: " + interfaceMember.Kind);			
			// WriteLine("//         member of interface: " + interfaceMember.Name);										
			if(interfaceMember.Kind.ToString() == "vsCMElementProperty")							
			{										
				// TODO: ALSO list all the properties potentially inherited by parent interface
				var property = (CodeProperty)interfaceMember;
				WriteLine("        //  Property : " + property.Name);										
				WriteLine("        //  Property Type : " + ((CodeTypeRef)property.Type).AsString);
				WriteLine("        //  Property : " + property.Access);										
				// WriteLine("       //  Property : " + prop.Comment);										
				// WriteLine("       //  Property : " + prop.Attributes);										
				// WriteLine("       //  Property : " + prop.Getter);										
				// WriteLine("       //  Property : " + prop.Setter);
				var propType = ((CodeTypeRef)property.Type).AsString;
				WriteLine("        public " + propType + " " + property.Name);	
				WriteLine("        { ");
				
				// TODO : Record the calls
				WriteLine("            get");					
				WriteLine("            {");					
				WriteLine("                this.PropertyGetCalls.Add(\""+ property.Name +"\");");				
				WriteLine("                return ("+propType+")this.Setups.Single(o => o.Item1 == \"" + property.Name + "\").Item3;");					
				WriteLine("            }");					
								
				
				// TODO : Record the calls
				WriteLine("            set");					
				WriteLine("            {");										
				WriteLine("                if (!this.IsVerifySetInProgess && !this.IsApplySetupSetInProgess)");				
				WriteLine("                {");						
				WriteLine("                    if(!this.SetupsPropertySet.Any(o => o.Item1 == \"" + property.Name + "\" && o.Item2(value) == true))");						
				WriteLine("                    {");						
				WriteLine("                        throw new NotSupportedException(\"No setup has been found for property setter "+ property.Name +" = \" + value);");				
				WriteLine("                    }");				
				WriteLine("                    this.PropertySetCalls.Add(new Tuple<string, object>(\""+ property.Name +"\", value));");				
				WriteLine("                }");				
				WriteLine("                if(this.IsVerifySetInProgess)");				
				WriteLine("                {");				
				WriteLine("                    // todo : make a single object containing the count AND the name of the method last verified.");				
				WriteLine("                    this.LastVerifySetMatchesCount = this.PropertySetCalls.Count(o => o.Item1 == \"" + property.Name + "\" && MatchIt.LastMatch.Any() ? MatchIt.LastMatch.Single()(value) : ("+propType+")o.Item2 ==  value);");				
				WriteLine("                    this.LastVerifySetPropertyName = \"" + property.Name + "\";");		
				WriteLine("                    MatchIt.LastMatch.Clear();");				
				WriteLine("                }");		
				WriteLine(string.Empty);				
				WriteLine("                // Maybe using an enum and a switch case instead of multiple if is better.");				
				WriteLine("                if (this.IsApplySetupSetInProgess)");				
				WriteLine("                {");				
				WriteLine("                    Func<object, bool> predicate;");
				WriteLine("                    if(MatchIt.LastMatch.Any())");
				WriteLine("                    {");
				WriteLine("                        var lastMatch = MatchIt.LastMatch.Single();");
				WriteLine("                        predicate = o => lastMatch(("+propType+")o);");
				WriteLine("                        MatchIt.LastMatch.Clear();");
				WriteLine("                    }");
				WriteLine("                    else");
				WriteLine("                    {");
				WriteLine("                        predicate = valueToTest => (("+propType+")valueToTest).Equals(value);");
				WriteLine("                    }");
				WriteLine("                    var setup = new Tuple<string, Func<object, bool>>(\""+property.Name+"\", predicate);");
				WriteLine("                    this.SetupsPropertySet.Add(setup);");
				WriteLine("                }");								
				WriteLine("            }");				
				
				WriteLine("        }");											
											
			}
			if(interfaceMember.Kind.ToString() == "vsCMElementFunction")							
			{
				// TODO : ALSO list all the methods potentially inherited by parent interface
				var function = (CodeFunction2)interfaceMember;
				var dotPosition = function.FullName.LastIndexOf('.');
				var functionName = function.FullName.Substring(dotPosition+1);
				WriteLine("//         Function : " + functionName);	
				WriteLine("//         Function : " + function.Name);	
				var returnType = ((CodeTypeRef)function.Type).AsString;
				WriteLine("//         Function Type: " + ((CodeTypeRef)function.Type).AsString);
												
				// http://msdn.microsoft.com/en-US/library/envdte.vscmaccess(v=vs.80).aspx
				WriteLine("//         Function : " + function.Access);	
				WriteLine("//         Function IsGeneric : " + function.IsGeneric);	

				// is it needed ?
				WriteLine("//         Function OL : " + function.Overloads);
												
				//WriteLine("//         Function args : " + function.Parameters);	

				string parms = string.Empty;

				string typeName = returnType;
				// if(returnType == typeof(void))
				// {
				// 	typeName = "void";
				// }
				// else
				// {
				// 	typeName = returnType;					
				// }
				Write(string.Format("        public {0} {1}(",  typeName , functionName));	
				//var parameters = method.GetParameters();
				bool isFirstIteration = true;
				foreach (CodeParameter param in function.Parameters)
				{					
					var paramType = ((CodeTypeRef)param.Type).AsString;																									
					//WriteLine("//             Function arg Type: " + ((CodeTypeRef)param.Type).AsString);	
					//WriteLine("//             Function arg Name: " + param.Name);	
					if(!isFirstIteration)
					{
						Write(", ");
					}
					Write(string.Format("{0} {1}", paramType, param.Name));	
					isFirstIteration = false;
				}
		
				WriteLine(")");
					 
				WriteLine("        {");	

				Write("            var args = new object[] { ");	
				var paramsCount = ((CodeElements)function.Parameters).Count;
				if(paramsCount == 0)
				{
					Write("null");	
				}
				else
				{
					isFirstIteration = true;
					foreach (CodeParameter param in function.Parameters)
					{		
						if(isFirstIteration == false)
						{
							Write(", ");
						}		
						//var paramType = ((CodeTypeRef)param.Type).AsString;																									
						Write(param.Name);	
						isFirstIteration = false;	
					}
					// Write("/* "+paramsCount+"  */");
					// Write(function.Parameters.Item(0).ToString());	
					// for (int i = 1; i < paramsCount; i++)
					// {
					// 	Write(string.Format(", {0}", function.Parameters.Item(i).Name));	              
					// }									
				}
				WriteLine(" };");	
				WriteLine("            if(this.IsApplySetupReturnsInProgess)");	
				WriteLine("            {");	
				int i = 0;
				foreach (CodeParameter param in function.Parameters)
				{		
					var paramPredicateVariableName =  param.Name+"Predicate";
					WriteLine("                Func<object, bool> "+paramPredicateVariableName+";");		
					var paramType = ((CodeTypeRef)param.Type).AsString;			
					WriteLine("                if(MatchIt.LastMatch.ElementAt("+i+") != null)");					
					WriteLine("                {");								
					WriteLine("                    var lastMatch = MatchIt.LastMatch.ElementAt("+i+");");									
					WriteLine("                    "+paramPredicateVariableName+" = o => lastMatch(("+ paramType +")o);");									
					WriteLine("                }");					
					WriteLine("                else");					
					WriteLine("                {");					
					WriteLine("                    " + paramPredicateVariableName + " = o => (("+paramType+")o).Equals("+param.Name+");");																																			
					WriteLine("                }");																																			
					i++;
				}			
				if(paramsCount == 0)
				{
					WriteLine("                var predicates = new Func<object, bool>[0];");	
				}
				else
				{
					Write("                var predicates = new [] { ");
					isFirstIteration = true;
					foreach (CodeParameter param in function.Parameters)
					{		
						if(isFirstIteration == false)
						{
							Write(", ");
						}		
						//var paramType = ((CodeTypeRef)param.Type).AsString;																									
						Write(param.Name +"Predicate");	
						isFirstIteration = false;	
					}
					WriteLine(" };");
				}
				WriteLine("                var setupTuple = new Tuple<string, Func<object, bool>[], object>(\""+functionName+"\", predicates, null);");	
				WriteLine("                this.Setups.Add(setupTuple);");	
				if (typeName != "void")
				{										
			
					WriteLine("                return default("+typeName+");");					
				}
				WriteLine("            }");	
				WriteLine("            else");	
				WriteLine("            {");	
				WriteLine("                var callRecord = new Tuple<string, object[]>( \"" + functionName + "\", args);");
															
				WriteLine("                this.Calls.Add(callRecord);");	
				// within the body of the class.



				// return value of the method 
				if (typeName != "void")
				{					
					WriteLine("                return ("+typeName+")this.Setups.Single(o => o.Item1 == \"" + functionName + "\" && this.AllArgumentsSatisfyPredicates(args, o.Item2)).Item3;");		
				}
				WriteLine("            }");	
				WriteLine("        }");					
				//WriteLine(string.Empty);					


			}
		}

		foreach(CodeInterface interfaceToMock in ce2.Bases)
		{
			WriteLine("        #region interface " + interfaceToMock.Name);	
			GenerateInterfaceMembers(interfaceToMock);
			WriteLine("        #endregion");	
		}
	}
  #>